{% extends "base.html" %}

{% block content %}
<h1>Fund Wallet</h1>
<div class="hero">
  Raiden needs funds for its operation
</div>

<div class="info-panel">
  <p>
    For example, ETH is required to create payment channels while RDN is the currency used
    by the
    <a href="https://medium.com/raiden-network/raiden-service-bundle-explained-f9bd3f6f358d" target="_blank">
      Raiden Service Bundle</a>.
    Please fund the Raiden account (with address below) with at least <strong>{{ minimum_eth_required.formatted }}</strong> and <strong>{{ minimum_rdn_required.formatted }}</strong>.</p>
  <p><em>If you don't have RDN tokens, send ETH and we can help you use it to buy RDN at a later step.</em></p>
  <p>Current balance</p>
  <ul class="account-info">
    <li>
      <span class="account-eth-balance highlighted">N/A ETH</span>
    </li>
    <li>
      <span class="account-rdn-balance highlighted">N/A RDN</span>
    </li>
  </ul>

  <p>Wallet Address</p>
  <div class="action-copy-paste">
    <span class="account-address highlighted">{{ configuration_file.account.address }}</span>
  </div>
</div>
<div class="action">
  <button disabled id="btn-web3" class="hide-when-disabled" onClick="sendViaWeb3(this);">
    Transfer via web3 browser
  </button>

  <button disabled
          id="btn-swap"
          class="link-button hide-when-disabled"
          data-link-url="{{ reverse_url('swap-options', configuration_file.file_name) }}">
    Convert ETH into RDN
  </button>
  <button disabled
          id="btn-launch" class="link-button hide-when-disabled"
          data-link-url="{{ reverse_url('launch', configuration_file.file_name) }}">
    Launch
  </button>
</div>
{% end %}


{% block page_header_scripts %}
<script type="text/javascript">
 const WEB3_ETH_AMOUNT_ATTRIBUTE = "data-requested-eth-amount";
 const WEB3_RDN_AMOUNT_ATTRIBUTE = "data-requested-rdn-amount";
 const KYBER_EXCHANGE_RATE_ATTRIBUTE = "data-kyber-exchange-rate";
 const CHAIN_ID = "{{ configuration_file.network.chain_id }}";

 function sendViaWeb3(button_elem) {
   const TARGET_ADDRESS = "{{ configuration_file.account.address }}";

   let eth_amount = button_elem.getAttribute(WEB3_ETH_AMOUNT_ATTRIBUTE);
   let rdn_amount = button_elem.getAttribute(WEB3_RDN_AMOUNT_ATTRIBUTE);
   let kyber_rate = button_elem.getAttribute(KYBER_EXCHANGE_RATE_ATTRIBUTE);
   let web3 = window.web3;

   if (eth_amount === null || rdn_amount === null) {
     console.error("No amount established to be sent");
     return
   }

   if (eth_amount <= 0 && rdn_amount <= 0) {
     alert("You have enough funds already!");
     return
   }

   let sender_address = (window.ethereum && window.ethereum.selectedAddress) || web3.eth.defaultAccount;

   let transaction_data = {
     from: sender_address,
     to: TARGET_ADDRESS,
     value: eth_amount
   }

   web3.eth.sendTransaction(transaction_data, function(error, result) {
     if (result) {
       // result is the transaction hash
       trackTransaction(result, "{{ configuration_file.file_name }}");
     }

     if (error) {
       console.error(error);
     }
   });
 };

 async function calculateNeededFunds() {
   let balance = await getBalances("{{ reverse_url('api-configuration-detail', configuration_file.file_name) }}");
   let kyber_exchange_rate = await getKyberExchangeRate("RDN");

   let eth_balance = balance && balance.ETH.as_wei;
   let rdn_balance = balance && balance.RDN.as_wei;

   let needed_eth = REQUIRED_ETH_AS_WEI;
   let needed_rdn = REQUIRED_RDN_AS_WEI;

   // If we already have some RDN, deduct from total needed
   if (rdn_balance) {
     needed_rdn -= rdn_balance;
   }

   // If we already have some ETH, deduct from total needed
   if (eth_balance) {
     needed_eth -= eth_balance;
   }

   // convert needed RDN into needed ETH for calculation via swap
   if (needed_rdn >= 0 && kyber_exchange_rate){
     needed_eth += (needed_rdn * kyber_exchange_rate);
   }

   needed_eth = Math.max(needed_eth, 0);
   needed_rdn = Math.max(needed_rdn, 0);

   return {
     account_status: balance,
     exchange_rates: {
       kyber: kyber_exchange_rate
     },
     eth: {
       balance: eth_balance,
       needed: needed_eth,
       swap_for_rdn: {
         kyber: (eth_balance && kyber_exchange_rate) && parseInt(eth_balance / kyber_exchange_rate)
       }
     },
     rdn: {
       balance: rdn_balance,
       needed: needed_rdn
     }
   }
 }

 function updateDisplay(calculated_funds) {
   let eth_balance_display_element = document.querySelector("span.account-eth-balance");
   let rdn_balance_display_element = document.querySelector("span.account-rdn-balance");

   updateBalanceDisplay(calculated_funds.account_status, eth_balance_display_element, rdn_balance_display_element);
 }

 async function updateActionButtons(balance) {}

 async function poll() {
   let calculated_funds = await calculateNeededFunds();

   let button_launch = document.getElementById("btn-launch");
   let button_swap = document.getElementById("btn-swap");
   let button_web3 = document.getElementById("btn-web3");
   let has_web3 = Boolean(window.ethereum || window.web3);

   updateDisplay(calculated_funds);

   let has_enough_eth = Boolean(calculated_funds.eth.needed <= 0);
   let has_enough_rdn = Boolean(calculated_funds.rdn.needed <= 0);

   let funds_for_kyber_swap = calculated_funds.eth.swap_for_rdn.kyber || 0;
   let needed_rdn = calculated_funds.rdn.needed;
   let needed_eth = calculated_funds.eth.needed;

   button_launch.disabled = !(has_enough_eth && has_enough_rdn);
   button_swap.disabled = !((funds_for_kyber_swap  > needed_rdn) && !has_enough_rdn);

   button_web3.setAttribute(WEB3_ETH_AMOUNT_ATTRIBUTE, needed_eth);
   button_web3.setAttribute(WEB3_RDN_AMOUNT_ATTRIBUTE, needed_rdn);
   button_web3.setAttribute(KYBER_EXCHANGE_RATE_ATTRIBUTE, calculated_funds.exchange_rates.kyber);
   button_web3.disabled = !(has_web3 && (!has_enough_eth || !has_enough_rdn));
 }

 window.addEventListener("load", async function () {
   let address_div_elem = document.querySelector("div.action-copy-paste");
   let account_address_elem = address_div_elem.querySelector("span.account-address");

   address_div_elem.addEventListener("click", function(evt) {
     copyToClipboard(address_div_elem, account_address_elem);
   });

   let has_web3 = Boolean(window.ethereum || window.web3);

   if (has_web3) {
     // Modern dapp browsers...
     if (window.ethereum) {
       console.log("Using modern dapp browser");
       window.web3 = new Web3(ethereum);
       try {
         // Request account access if needed
         await ethereum.enable();

         web3.version.getNetwork(function(error, chain_id){
           if (error) {
             console.error(error);             
           }

           if (chain_id != CHAIN_ID) {
             alert("Web3 Browser detected, but not connected to {{ network.capitalized_name }}");
           }
         });
       } catch (error) {
         console.log(error);
       }
     }
     // Legacy dapp browsers...
     else if (window.web3) {
       console.log("Using legacy web3");
       window.web3 = new Web3(web3.currentProvider);
     }
     // Non-dapp browsers...
     else {
       console.log('Non-Ethereum browser detected. You should consider trying MetaMask!');
     }
   }

   poll();

   setInterval(poll, 5000);
 });
</script>
{% end %}
